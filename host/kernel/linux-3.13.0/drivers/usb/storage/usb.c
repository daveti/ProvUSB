/* Driver for USB Mass Storage compliant devices
 *
 * Current development and maintenance by:
 *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
 *
 * Developed with the assistance of:
 *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)
 *   (c) 2003-2009 Alan Stern (stern@rowland.harvard.edu)
 *
 * Initial work by:
 *   (c) 1999 Michael Gee (michael@linuxspecific.com)
 *
 * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):
 *   (c) 2000 Yggdrasil Computing, Inc.
 *
 * This driver is based on the 'USB Mass Storage Class' document. This
 * describes in detail the protocol used to communicate with such
 * devices.  Clearly, the designers had SCSI and ATAPI commands in
 * mind when they created this document.  The commands are all very
 * similar to commands in the SCSI-II and ATAPI specifications.
 *
 * It is important to note that in a number of cases this class
 * exhibits class-specific exemptions from the USB specification.
 * Notably the usage of NAK, STALL and ACK differs from the norm, in
 * that they are used to communicate wait, failed and OK on commands.
 *
 * Also, for certain devices, the interrupt endpoint is used to convey
 * status of a command.
 *
 * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more
 * information about this driver.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifdef CONFIG_USB_STORAGE_DEBUG
#define DEBUG
#endif

#include <linux/sched.h>
#include <linux/errno.h>
#include <linux/freezer.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/kthread.h>
#include <linux/mutex.h>
#include <linux/utsname.h>

/* daveti: add support for the netlink socket */
#include <linux/netlink.h>
#include <linux/skbuff.h>
#include <linux/delay.h>
#include <linux/wait.h>
#include <linux/time.h>	/* ProvUSB perf */

#include <scsi/scsi.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_device.h>

#include "usb.h"
#include "scsiglue.h"
#include "transport.h"
#include "protocol.h"
#include "debug.h"
#include "initializers.h"

#include "sierra_ms.h"
#include "option_ms.h"

/* Some informational data */
MODULE_AUTHOR("Matthew Dharm <mdharm-usb@one-eyed-alien.net>");
MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
MODULE_LICENSE("GPL");

static unsigned int delay_use = 1;
module_param(delay_use, uint, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");

static char quirks[128];
module_param_string(quirks, quirks, sizeof(quirks), S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(quirks, "supplemental list of device IDs and their quirks");


/*
 * The entries in this table correspond, line for line,
 * with the entries in usb_storage_usb_ids[], defined in usual-tables.c.
 */

/* The vendor name should be kept at eight characters or less, and
 * the product name should be kept at 16 characters or less. If a device
 * has the US_FL_FIX_INQUIRY flag, then the vendor and product names
 * normally generated by a device thorugh the INQUIRY response will be
 * taken from this list, and this is the reason for the above size
 * restriction. However, if the flag is not present, then you
 * are free to use as many characters as you like.
 */

#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \
		    vendor_name, product_name, use_protocol, use_transport, \
		    init_function, Flags) \
{ \
	.vendorName = vendor_name,	\
	.productName = product_name,	\
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
	.initFunction = init_function,	\
}

#define COMPLIANT_DEV	UNUSUAL_DEV

#define USUAL_DEV(use_protocol, use_transport) \
{ \
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
}

#define UNUSUAL_VENDOR_INTF(idVendor, cl, sc, pr, \
		vendor_name, product_name, use_protocol, use_transport, \
		init_function, Flags) \
{ \
	.vendorName = vendor_name,	\
	.productName = product_name,	\
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
	.initFunction = init_function,	\
}

static struct us_unusual_dev us_unusual_dev_list[] = {
#	include "unusual_devs.h"
	{ }		/* Terminating entry */
};

static struct us_unusual_dev for_dynamic_ids =
		USUAL_DEV(USB_SC_SCSI, USB_PR_BULK);

#undef UNUSUAL_DEV
#undef COMPLIANT_DEV
#undef USUAL_DEV
#undef UNUSUAL_VENDOR_INTF

/* daveti: general USB storage ctrl block for the trsuted device */
static struct us_trusted_dev_ctrl us_trusted_dev_ctrl_block;
/* phase 0 - real testing
 * phase 1 - UT between USB host and the tpmd
 * phase 2 - UT between USB host and USB device
 */
static u8 us_trusted_dev_ut_phase = 0;
static u8 us_trusted_dev_debug = 0;
static u8 us_trusted_dev_adsc_debug = 0;
static u8 us_trusted_dev_nl_wakeup = 1;
static u8 us_trusted_dev_perf = 1;
static u8 us_trusted_dev_perf_kernel_logging = 1;
static u8 us_trusted_dev_provusb_disable = 0;
/* ProvUSB perf */
#define PROVUSB_MBM_SEC_IN_USEC         1000000         /* ProvUSB micro benchmark */
#define PROVUSB_MBM_SUB_TV(s, e)                \
        ((e.tv_sec*PROVUSB_MBM_SEC_IN_USEC+e.tv_usec) - \
        (s.tv_sec*PROVUSB_MBM_SEC_IN_USEC+s.tv_usec))

/*
 * daveti: us_trusted_dev_tpm_nl_send_request
 * Send the request msg to the tpmd
 */
static int us_trusted_dev_tpm_nl_send_request(u8 *data, int len)
{
        struct nlmsghdr *nlh;
        struct sk_buff *skb_out;
        struct us_trusted_dev_tpm_nl_msg msg_req;
        int msg_size;
	int data_len;
        int rtn;

	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

	/* Defensive checking */
	if (!us_trusted_dev_ctrl_block.tpm_pid) {
		printk(KERN_ERR "daveti2: tpmd pid is unknown yet - abort\n");
		return -1;
	}

        /* Construct the request */
        msg_size = sizeof(msg_req);
        memset(&msg_req, 0, msg_size);
        msg_req.opcode = US_TRUSTED_DEV_TPM_ATT_MSG_REQ;

	/* Defensive checking */
	if (len > US_TRUSTED_DEV_TPM_ATT_REQ_LEN) {
		printk(KERN_ERR "daveti2: data len [%d] excceeds the max supported len [%d]\n",
				len, US_TRUSTED_DEV_TPM_ATT_REQ_LEN);
		data_len = US_TRUSTED_DEV_TPM_ATT_REQ_LEN;
	}
	else {
		data_len = len;
	}

	/* Check if this is a goodbye msg to tpmd */
	if (data_len == 0) {
		msg_req.opcode = US_TRUSTED_DEV_TPM_ATT_MSG_BYE;
	}
	else {
		/* Copy the data into the request */
		memcpy(msg_req.req, data, data_len);
	}

        /* Send the msg from kernel to the user */
        skb_out = nlmsg_new(msg_size, 0);
        if (!skb_out) {
                printk(KERN_ERR "daveti2: failed to allocate new skb\n");
                return -1;
        }

        nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, 0);
        NETLINK_CB(skb_out).dst_group = 0; /* not in mcast group */
        memcpy(nlmsg_data(nlh), &msg_req, msg_size);

        rtn = nlmsg_unicast(us_trusted_dev_ctrl_block.tpm_nl_sock,
			skb_out,
			us_trusted_dev_ctrl_block.tpm_pid);
        if (rtn) {
                printk(KERN_ERR "daveti2: failed to send request to tpmd\n");
                return -1;
        }

	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: sent an ATT request to the tpmd\n");

        return 0;
}

/*
 * daveti: us_trusted_dev_tpm_nl_init
 * Process the init msg from the tpmd
 */
static int us_trusted_dev_tpm_nl_init(struct nlmsghdr *nlh)
{
        int rtn = 0;
        /* Make sure strlen(msg) <= 23! */
        char *msg = "_hello_from_kernel_";

	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

        if (nlh != NULL) {
                us_trusted_dev_ctrl_block.tpm_pid = nlh->nlmsg_pid; /*pid of sending process */
                printk(KERN_INFO "daveti2: tpmd pid [%d]\n",
			us_trusted_dev_ctrl_block.tpm_pid);

                /* Send hello to the tpmd */
                rtn = us_trusted_dev_tpm_nl_send_request(msg, strlen(msg)+1);
                if (rtn != 0)
                        printk(KERN_ERR "daveti2: us_trusted_dev_tpm_nl_send_request() failed\n");
                else
                        printk(KERN_INFO "daveti2: sent hello msg to tpmd\n");
        }

        return rtn;
}

/*
 * daveti: us_trusted_dev_free_tpmd
 * Send goodbye msg to the tpmd
 */
static int us_trusted_dev_free_tpmd(void)
{
        int rtn = 0;

	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

	/* Send goodbye to the tpmd */
	rtn = us_trusted_dev_tpm_nl_send_request(NULL, 0);
	if (rtn != 0)
		printk(KERN_ERR "daveti2: us_trusted_dev_tpm_nl_send_request() failed\n");
	else
		printk(KERN_INFO "daveti2: sent goodbye msg to tpmd\n");

        return rtn;
}

/*
 * daveti: us_trusted_dev_tpm_nl_process_reply
 * Process the reply msg from the tpmd
 */
static int us_trusted_dev_tpm_nl_process_reply(struct us_trusted_dev_tpm_nl_msg *msg_ptr)
{
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

	/* Update the global tpm quote store */
	mutex_lock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);
	memcpy(us_trusted_dev_ctrl_block.tpm_quote_store.quote,
		msg_ptr->rep,
		US_TRUSTED_DEV_TPM_ATT_REP_LEN);
	us_trusted_dev_ctrl_block.tpm_quote_store.sent_len = 0;
	/* According to the new protocol,
	 * we need both AIK and the TPM quote.
	 * We are NOT ready if AIK is missing from arpsecd
	 * Jan 20, 2015
	 * daveti
	 */
	if (us_trusted_dev_ctrl_block.tpm_quote_store.aik_pub_key == 0) {
		pr_err("daveti2: Error - got TPM quote before AIK public key\n");
		us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go =
			US_TRUSTED_DEV_TPM_QUOTE_NOT_READY;
	} else {
		pr_info("daveti2: TPM quote store is ready to go\n");
		us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go =
			US_TRUSTED_DEV_TPM_QUOTE_READY;
	}
	mutex_unlock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);

	/* Wake up ourself */
	if (us_trusted_dev_nl_wakeup)
		wake_up(&us_trusted_dev_ctrl_block.tpm_wait);

	/* Debug */
	if (us_trusted_dev_debug) {
		printk(KERN_INFO "daveti2: got the TPM quote from tpmd\n");
		print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
				us_trusted_dev_ctrl_block.tpm_quote_store.quote,
				US_TRUSTED_DEV_TPM_ATT_REP_LEN, 0);
	}

        return 0;
}

/*
 * daveti: us_trusted_dev_tpm_nl_process_aik
 * Process the aik msg from the tpmd
 */
static int us_trusted_dev_tpm_nl_process_aik(struct us_trusted_dev_tpm_nl_msg *msg_ptr)
{
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

        /* Update the global tpm quote store */
        mutex_lock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);
        memcpy(us_trusted_dev_ctrl_block.tpm_quote_store.aik,
                msg_ptr->rep,
                US_TRUSTED_DEV_TPM_ATT_AIK_PUB_LEN);
	us_trusted_dev_ctrl_block.tpm_quote_store.aik_pub_key = 1;
	/* Do not update the ready_to_go flag as we are waiting
	 * for the TPM quote - even though we may send AIK pub key
	 * instead of TPM quote during early phase.
	 * Jul 26, 2014
	 * daveti
	us_trusted_dev_ctrl_block.tpm_quote_store.sent_len = 0;
        us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go =
                US_TRUSTED_DEV_TPM_QUOTE_READY;
	 */
        mutex_unlock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);

	/* Debug */
	if (us_trusted_dev_debug) {
		printk(KERN_INFO "daveti2: got AIK pub key from tpmd:\n");
		print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
				us_trusted_dev_ctrl_block.tpm_quote_store.aik,
				US_TRUSTED_DEV_TPM_ATT_AIK_PUB_LEN, 0);
	}

        return 0;
}

/*
 * daveti: us_trusted_dev_tpm_nl_handler
 * Process the ATT msg from the tpmd
 */
static void us_trusted_dev_tpm_nl_handler(struct sk_buff *skb)
{
        struct nlmsghdr *nlh;
        struct us_trusted_dev_tpm_nl_msg *us_tpm_nlmsg_ptr;
        u8 opcode;
        int rtn;

	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: entering [%s]\n", __FUNCTION__);

        /* Retrive the opcode */
        nlh = (struct nlmsghdr*)skb->data;
        us_tpm_nlmsg_ptr = (struct us_trusted_dev_tpm_nl_msg *)nlmsg_data(nlh);
        opcode = us_tpm_nlmsg_ptr->opcode;
        printk(KERN_INFO "daveti2: netlink received msg opcode [%u]\n", opcode);

        switch (opcode)
        {
                case US_TRUSTED_DEV_TPM_ATT_MSG_INIT:
                        rtn = us_trusted_dev_tpm_nl_init(nlh);
                        break;

                case US_TRUSTED_DEV_TPM_ATT_MSG_REP:
                        rtn = us_trusted_dev_tpm_nl_process_reply(us_tpm_nlmsg_ptr);
                        break;

		case US_TRUSTED_DEV_TPM_ATT_MSG_AIK:
			rtn = us_trusted_dev_tpm_nl_process_aik(us_tpm_nlmsg_ptr);
			break;

                default:
                        rtn = 0;
                        printk(KERN_ERR "daveti2: unsupported netlink opcode [%u]\n", opcode);
        }

        if (rtn < 0)
                printk(KERN_ERR "daveti2: netlink processing failure\n");
}

/*
 * daveti: us_trusted_dev_init_ctrl_block
 * Init the USB storage ctrl block for the trusted device
 */
static void us_trusted_dev_init_ctrl_block(struct us_trusted_dev_ctrl *block)
{
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);
 
        /* Init the tpmd pid */
        block->tpm_pid = 0;

        /* Init the netlink socket */
        block->tpm_nl_sock = NULL;

        struct netlink_kernel_cfg cfg = {
                .input = us_trusted_dev_tpm_nl_handler,
        };

        if (!block->tpm_nl_sock) {
                block->tpm_nl_sock = netlink_kernel_create(&init_net,
                                                        US_TRUSTED_DEV_NETLINK_SOCK,
                                                        &cfg);
                if(!block->tpm_nl_sock) 
                        printk(KERN_ERR "daveti2: netlink socket creation failure in USB storage\n");
                
                printk(KERN_INFO "daveti2: netlink socket created in USB storage\n");
        }

        /* Init the tpm quote store */
        memset(&block->tpm_quote_store, 0x0, sizeof(struct us_trusted_dev_tpm_quote_store));
        mutex_init(&block->tpm_quote_store.lock);

	/* Init the tpm wait queue */
	init_waitqueue_head(&block->tpm_wait);
}

/*
 * daveti: us_trusted_dev_free_ctrl_block
 * Free the USB storage ctrl block for the trusted device
 */
static void us_trusted_dev_free_ctrl_block(struct us_trusted_dev_ctrl *block)
{
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into [%s]\n", __FUNCTION__);

	/* Free the netlink socket */
        if (block->tpm_nl_sock) {
                netlink_kernel_release(block->tpm_nl_sock);
                printk(KERN_INFO "daveti2: USB-TPM netlink socket is closed\n");
        }
}

/* daveti: end of the netlink socket support */

#ifdef CONFIG_LOCKDEP

static struct lock_class_key us_interface_key[USB_MAXINTERFACES];

static void us_set_lock_class(struct mutex *mutex,
		struct usb_interface *intf)
{
	struct usb_device *udev = interface_to_usbdev(intf);
	struct usb_host_config *config = udev->actconfig;
	int i;

	for (i = 0; i < config->desc.bNumInterfaces; i++) {
		if (config->interface[i] == intf)
			break;
	}

	BUG_ON(i == config->desc.bNumInterfaces);

	lockdep_set_class(mutex, &us_interface_key[i]);
}

#else

static void us_set_lock_class(struct mutex *mutex,
		struct usb_interface *intf)
{
}

#endif

#ifdef CONFIG_PM	/* Minimal support for suspend and resume */

int usb_stor_suspend(struct usb_interface *iface, pm_message_t message)
{
	struct us_data *us = usb_get_intfdata(iface);

	/* Wait until no command is running */
	mutex_lock(&us->dev_mutex);

	if (us->suspend_resume_hook)
		(us->suspend_resume_hook)(us, US_SUSPEND);

	/* When runtime PM is working, we'll set a flag to indicate
	 * whether we should autoresume when a SCSI request arrives. */

	mutex_unlock(&us->dev_mutex);
	return 0;
}
EXPORT_SYMBOL_GPL(usb_stor_suspend);

int usb_stor_resume(struct usb_interface *iface)
{
	struct us_data *us = usb_get_intfdata(iface);

	mutex_lock(&us->dev_mutex);

	if (us->suspend_resume_hook)
		(us->suspend_resume_hook)(us, US_RESUME);

	mutex_unlock(&us->dev_mutex);
	return 0;
}
EXPORT_SYMBOL_GPL(usb_stor_resume);

int usb_stor_reset_resume(struct usb_interface *iface)
{
	struct us_data *us = usb_get_intfdata(iface);

	/* Report the reset to the SCSI core */
	usb_stor_report_bus_reset(us);

	/* FIXME: Notify the subdrivers that they need to reinitialize
	 * the device */
	return 0;
}
EXPORT_SYMBOL_GPL(usb_stor_reset_resume);

#endif /* CONFIG_PM */

/*
 * The next two routines get called just before and just after
 * a USB port reset, whether from this driver or a different one.
 */

int usb_stor_pre_reset(struct usb_interface *iface)
{
	struct us_data *us = usb_get_intfdata(iface);

	/* Make sure no command runs during the reset */
	mutex_lock(&us->dev_mutex);
	return 0;
}
EXPORT_SYMBOL_GPL(usb_stor_pre_reset);

int usb_stor_post_reset(struct usb_interface *iface)
{
	struct us_data *us = usb_get_intfdata(iface);

	/* Report the reset to the SCSI core */
	usb_stor_report_bus_reset(us);

	/* FIXME: Notify the subdrivers that they need to reinitialize
	 * the device */

	mutex_unlock(&us->dev_mutex);
	return 0;
}
EXPORT_SYMBOL_GPL(usb_stor_post_reset);

/*
 * fill_inquiry_response takes an unsigned char array (which must
 * be at least 36 characters) and populates the vendor name,
 * product name, and revision fields. Then the array is copied
 * into the SCSI command's response buffer (oddly enough
 * called request_buffer). data_len contains the length of the
 * data array, which again must be at least 36.
 */

void fill_inquiry_response(struct us_data *us, unsigned char *data,
		unsigned int data_len)
{
	if (data_len < 36) /* You lose. */
		return;

	memset(data+8, ' ', 28);
	if (data[0]&0x20) { /* USB device currently not connected. Return
			      peripheral qualifier 001b ("...however, the
			      physical device is not currently connected
			      to this logical unit") and leave vendor and
			      product identification empty. ("If the target
			      does store some of the INQUIRY data on the
			      device, it may return zeros or ASCII spaces
			      (20h) in those fields until the data is
			      available from the device."). */
	} else {
		u16 bcdDevice = le16_to_cpu(us->pusb_dev->descriptor.bcdDevice);
		int n;

		n = strlen(us->unusual_dev->vendorName);
		memcpy(data+8, us->unusual_dev->vendorName, min(8, n));
		n = strlen(us->unusual_dev->productName);
		memcpy(data+16, us->unusual_dev->productName, min(16, n));

		data[32] = 0x30 + ((bcdDevice>>12) & 0x0F);
		data[33] = 0x30 + ((bcdDevice>>8) & 0x0F);
		data[34] = 0x30 + ((bcdDevice>>4) & 0x0F);
		data[35] = 0x30 + ((bcdDevice) & 0x0F);
	}

	usb_stor_set_xfer_buf(data, data_len, us->srb);
}
EXPORT_SYMBOL_GPL(fill_inquiry_response);

static int usb_stor_control_thread(void * __us)
{
	struct us_data *us = (struct us_data *)__us;
	struct Scsi_Host *host = us_to_host(us);

	for (;;) {
		usb_stor_dbg(us, "*** thread sleeping\n");
		if (wait_for_completion_interruptible(&us->cmnd_ready))
			break;

		usb_stor_dbg(us, "*** thread awakened\n");

		/* lock the device pointers */
		mutex_lock(&(us->dev_mutex));

		/* lock access to the state */
		scsi_lock(host);

		/* When we are called with no command pending, we're done */
		if (us->srb == NULL) {
			scsi_unlock(host);
			mutex_unlock(&us->dev_mutex);
			usb_stor_dbg(us, "-- exiting\n");
			break;
		}

		/* has the command timed out *already* ? */
		if (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {
			us->srb->result = DID_ABORT << 16;
			goto SkipForAbort;
		}

		scsi_unlock(host);

		/* reject the command if the direction indicator
		 * is UNKNOWN
		 */
		if (us->srb->sc_data_direction == DMA_BIDIRECTIONAL) {
			usb_stor_dbg(us, "UNKNOWN data direction\n");
			us->srb->result = DID_ERROR << 16;
		}

		/* reject if target != 0 or if LUN is higher than
		 * the maximum known LUN
		 */
		else if (us->srb->device->id &&
				!(us->fflags & US_FL_SCM_MULT_TARG)) {
			usb_stor_dbg(us, "Bad target number (%d:%d)\n",
				     us->srb->device->id, us->srb->device->lun);
			us->srb->result = DID_BAD_TARGET << 16;
		}

		else if (us->srb->device->lun > us->max_lun) {
			usb_stor_dbg(us, "Bad LUN (%d:%d)\n",
				     us->srb->device->id, us->srb->device->lun);
			us->srb->result = DID_BAD_TARGET << 16;
		}

		/* Handle those devices which need us to fake
		 * their inquiry data */
		else if ((us->srb->cmnd[0] == INQUIRY) &&
			    (us->fflags & US_FL_FIX_INQUIRY)) {
			unsigned char data_ptr[36] = {
			    0x00, 0x80, 0x02, 0x02,
			    0x1F, 0x00, 0x00, 0x00};

			usb_stor_dbg(us, "Faking INQUIRY command\n");
			fill_inquiry_response(us, data_ptr, 36);
			us->srb->result = SAM_STAT_GOOD;
		}

		/* we've got a command, let's do it! */
		else {
			US_DEBUG(usb_stor_show_command(us, us->srb));
			us->proto_handler(us->srb, us);
			usb_mark_last_busy(us->pusb_dev);
		}

		/* lock access to the state */
		scsi_lock(host);

		/* indicate that the command is done */
		if (us->srb->result != DID_ABORT << 16) {
			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
				     us->srb->result);
			us->srb->scsi_done(us->srb);
		} else {
SkipForAbort:
			usb_stor_dbg(us, "scsi command aborted\n");
		}

		/* If an abort request was received we need to signal that
		 * the abort has finished.  The proper test for this is
		 * the TIMED_OUT flag, not srb->result == DID_ABORT, because
		 * the timeout might have occurred after the command had
		 * already completed with a different result code. */
		if (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {
			complete(&(us->notify));

			/* Allow USB transfers to resume */
			clear_bit(US_FLIDX_ABORTING, &us->dflags);
			clear_bit(US_FLIDX_TIMED_OUT, &us->dflags);
		}

		/* finished working on this command */
		us->srb = NULL;
		scsi_unlock(host);

		/* unlock the device pointers */
		mutex_unlock(&us->dev_mutex);
	} /* for (;;) */

	/* Wait until we are told to stop */
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kthread_should_stop())
			break;
		schedule();
	}
	__set_current_state(TASK_RUNNING);
	return 0;
}

/***********************************************************************
 * Device probing and disconnecting
 ***********************************************************************/

/* Associate our private data with the USB device */
static int associate_dev(struct us_data *us, struct usb_interface *intf)
{
	/* Fill in the device-related fields */
	us->pusb_dev = interface_to_usbdev(intf);
	us->pusb_intf = intf;
	us->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;
	usb_stor_dbg(us, "Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x\n",
		     le16_to_cpu(us->pusb_dev->descriptor.idVendor),
		     le16_to_cpu(us->pusb_dev->descriptor.idProduct),
		     le16_to_cpu(us->pusb_dev->descriptor.bcdDevice));
	usb_stor_dbg(us, "Interface Subclass: 0x%02x, Protocol: 0x%02x\n",
		     intf->cur_altsetting->desc.bInterfaceSubClass,
		     intf->cur_altsetting->desc.bInterfaceProtocol);

	/* Store our private data in the interface */
	usb_set_intfdata(intf, us);

	/* Allocate the control/setup and DMA-mapped buffers */
	us->cr = kmalloc(sizeof(*us->cr), GFP_KERNEL);
	if (!us->cr)
		return -ENOMEM;

	us->iobuf = usb_alloc_coherent(us->pusb_dev, US_IOBUF_SIZE,
			GFP_KERNEL, &us->iobuf_dma);
	if (!us->iobuf) {
		usb_stor_dbg(us, "I/O buffer allocation failed\n");
		return -ENOMEM;
	}
	return 0;
}

/* Works only for digits and letters, but small and fast */
#define TOLOWER(x) ((x) | 0x20)

/* Adjust device flags based on the "quirks=" module parameter */
static void adjust_quirks(struct us_data *us)
{
	char *p;
	u16 vid = le16_to_cpu(us->pusb_dev->descriptor.idVendor);
	u16 pid = le16_to_cpu(us->pusb_dev->descriptor.idProduct);
	unsigned f = 0;
	unsigned int mask = (US_FL_SANE_SENSE | US_FL_BAD_SENSE |
			US_FL_FIX_CAPACITY |
			US_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |
			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
			US_FL_INITIAL_READ10 | US_FL_WRITE_CACHE);

	p = quirks;
	while (*p) {
		/* Each entry consists of VID:PID:flags */
		if (vid == simple_strtoul(p, &p, 16) &&
				*p == ':' &&
				pid == simple_strtoul(p+1, &p, 16) &&
				*p == ':')
			break;

		/* Move forward to the next entry */
		while (*p) {
			if (*p++ == ',')
				break;
		}
	}
	if (!*p)	/* No match */
		return;

	/* Collect the flags */
	while (*++p && *p != ',') {
		switch (TOLOWER(*p)) {
		case 'a':
			f |= US_FL_SANE_SENSE;
			break;
		case 'b':
			f |= US_FL_BAD_SENSE;
			break;
		case 'c':
			f |= US_FL_FIX_CAPACITY;
			break;
		case 'd':
			f |= US_FL_NO_READ_DISC_INFO;
			break;
		case 'e':
			f |= US_FL_NO_READ_CAPACITY_16;
			break;
		case 'h':
			f |= US_FL_CAPACITY_HEURISTICS;
			break;
		case 'i':
			f |= US_FL_IGNORE_DEVICE;
			break;
		case 'l':
			f |= US_FL_NOT_LOCKABLE;
			break;
		case 'm':
			f |= US_FL_MAX_SECTORS_64;
			break;
		case 'n':
			f |= US_FL_INITIAL_READ10;
			break;
		case 'o':
			f |= US_FL_CAPACITY_OK;
			break;
		case 'p':
			f |= US_FL_WRITE_CACHE;
			break;
		case 'r':
			f |= US_FL_IGNORE_RESIDUE;
			break;
		case 's':
			f |= US_FL_SINGLE_LUN;
			break;
		case 'w':
			f |= US_FL_NO_WP_DETECT;
			break;
		/* Ignore unrecognized flag characters */
		}
	}
	us->fflags = (us->fflags & ~mask) | f;
}

/* Get the unusual_devs entries and the string descriptors */
static int get_device_info(struct us_data *us, const struct usb_device_id *id,
		struct us_unusual_dev *unusual_dev)
{
	struct usb_device *dev = us->pusb_dev;
	struct usb_interface_descriptor *idesc =
		&us->pusb_intf->cur_altsetting->desc;
	struct device *pdev = &us->pusb_intf->dev;

	/* Store the entries */
	us->unusual_dev = unusual_dev;
	us->subclass = (unusual_dev->useProtocol == USB_SC_DEVICE) ?
			idesc->bInterfaceSubClass :
			unusual_dev->useProtocol;
	us->protocol = (unusual_dev->useTransport == USB_PR_DEVICE) ?
			idesc->bInterfaceProtocol :
			unusual_dev->useTransport;
	us->fflags = id->driver_info;
	adjust_quirks(us);

	if (us->fflags & US_FL_IGNORE_DEVICE) {
		dev_info(pdev, "device ignored\n");
		return -ENODEV;
	}

	/*
	 * This flag is only needed when we're in high-speed, so let's
	 * disable it if we're in full-speed
	 */
	if (dev->speed != USB_SPEED_HIGH)
		us->fflags &= ~US_FL_GO_SLOW;

	if (us->fflags)
		dev_info(pdev, "Quirks match for vid %04x pid %04x: %lx\n",
				le16_to_cpu(dev->descriptor.idVendor),
				le16_to_cpu(dev->descriptor.idProduct),
				us->fflags);

	/* Log a message if a non-generic unusual_dev entry contains an
	 * unnecessary subclass or protocol override.  This may stimulate
	 * reports from users that will help us remove unneeded entries
	 * from the unusual_devs.h table.
	 */
	if (id->idVendor || id->idProduct) {
		static const char *msgs[3] = {
			"an unneeded SubClass entry",
			"an unneeded Protocol entry",
			"unneeded SubClass and Protocol entries"};
		struct usb_device_descriptor *ddesc = &dev->descriptor;
		int msg = -1;

		if (unusual_dev->useProtocol != USB_SC_DEVICE &&
			us->subclass == idesc->bInterfaceSubClass)
			msg += 1;
		if (unusual_dev->useTransport != USB_PR_DEVICE &&
			us->protocol == idesc->bInterfaceProtocol)
			msg += 2;
		if (msg >= 0 && !(us->fflags & US_FL_NEED_OVERRIDE))
			dev_notice(pdev, "This device "
					"(%04x,%04x,%04x S %02x P %02x)"
					" has %s in unusual_devs.h (kernel"
					" %s)\n"
					"   Please send a copy of this message to "
					"<linux-usb@vger.kernel.org> and "
					"<usb-storage@lists.one-eyed-alien.net>\n",
					le16_to_cpu(ddesc->idVendor),
					le16_to_cpu(ddesc->idProduct),
					le16_to_cpu(ddesc->bcdDevice),
					idesc->bInterfaceSubClass,
					idesc->bInterfaceProtocol,
					msgs[msg],
					utsname()->release);
	}

	return 0;
}

/* Get the transport settings */
static void get_transport(struct us_data *us)
{
	switch (us->protocol) {
	case USB_PR_CB:
		us->transport_name = "Control/Bulk";
		us->transport = usb_stor_CB_transport;
		us->transport_reset = usb_stor_CB_reset;
		us->max_lun = 7;
		break;

	case USB_PR_CBI:
		us->transport_name = "Control/Bulk/Interrupt";
		us->transport = usb_stor_CB_transport;
		us->transport_reset = usb_stor_CB_reset;
		us->max_lun = 7;
		break;

	case USB_PR_BULK:
		us->transport_name = "Bulk";
		us->transport = usb_stor_Bulk_transport;
		us->transport_reset = usb_stor_Bulk_reset;
		break;
	}
}

/* Get the protocol settings */
static void get_protocol(struct us_data *us)
{
	switch (us->subclass) {
	case USB_SC_RBC:
		us->protocol_name = "Reduced Block Commands (RBC)";
		us->proto_handler = usb_stor_transparent_scsi_command;
		break;

	case USB_SC_8020:
		us->protocol_name = "8020i";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		break;

	case USB_SC_QIC:
		us->protocol_name = "QIC-157";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		break;

	case USB_SC_8070:
		us->protocol_name = "8070i";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		break;

	case USB_SC_SCSI:
		us->protocol_name = "Transparent SCSI";
		us->proto_handler = usb_stor_transparent_scsi_command;
		break;

	case USB_SC_UFI:
		us->protocol_name = "Uniform Floppy Interface (UFI)";
		us->proto_handler = usb_stor_ufi_command;
		break;
	}
}

/* Get the pipe settings */
static int get_pipes(struct us_data *us)
{
	struct usb_host_interface *altsetting =
		us->pusb_intf->cur_altsetting;
	int i;
	struct usb_endpoint_descriptor *ep;
	struct usb_endpoint_descriptor *ep_in = NULL;
	struct usb_endpoint_descriptor *ep_out = NULL;
	struct usb_endpoint_descriptor *ep_int = NULL;

	/*
	 * Find the first endpoint of each type we need.
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt-in is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 */
	for (i = 0; i < altsetting->desc.bNumEndpoints; i++) {
		ep = &altsetting->endpoint[i].desc;

		if (usb_endpoint_xfer_bulk(ep)) {
			if (usb_endpoint_dir_in(ep)) {
				if (!ep_in)
					ep_in = ep;
			} else {
				if (!ep_out)
					ep_out = ep;
			}
		}

		else if (usb_endpoint_is_int_in(ep)) {
			if (!ep_int)
				ep_int = ep;
		}
	}

	if (!ep_in || !ep_out || (us->protocol == USB_PR_CBI && !ep_int)) {
		usb_stor_dbg(us, "Endpoint sanity check failed! Rejecting dev.\n");
		return -EIO;
	}

	/* Calculate and store the pipe values */
	us->send_ctrl_pipe = usb_sndctrlpipe(us->pusb_dev, 0);
	us->recv_ctrl_pipe = usb_rcvctrlpipe(us->pusb_dev, 0);
	us->send_bulk_pipe = usb_sndbulkpipe(us->pusb_dev,
		usb_endpoint_num(ep_out));
	us->recv_bulk_pipe = usb_rcvbulkpipe(us->pusb_dev,
		usb_endpoint_num(ep_in));
	if (ep_int) {
		us->recv_intr_pipe = usb_rcvintpipe(us->pusb_dev,
			usb_endpoint_num(ep_int));
		us->ep_bInterval = ep_int->bInterval;
	}
	return 0;
}

/* Initialize all the dynamic resources we need */
static int usb_stor_acquire_resources(struct us_data *us)
{
	int p;
	struct task_struct *th;

	us->current_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!us->current_urb) {
		usb_stor_dbg(us, "URB allocation failed\n");
		return -ENOMEM;
	}

	/* Just before we start our control thread, initialize
	 * the device if it needs initialization */
	if (us->unusual_dev->initFunction) {
		p = us->unusual_dev->initFunction(us);
		if (p)
			return p;
	}

	/* Start up our control thread */
	th = kthread_run(usb_stor_control_thread, us, "usb-storage");
	if (IS_ERR(th)) {
		dev_warn(&us->pusb_intf->dev,
				"Unable to start control thread\n");
		return PTR_ERR(th);
	}
	us->ctl_thread = th;

	return 0;
}

/* Release all our dynamic resources */
static void usb_stor_release_resources(struct us_data *us)
{
	/* Tell the control thread to exit.  The SCSI host must
	 * already have been removed and the DISCONNECTING flag set
	 * so that we won't accept any more commands.
	 */
	usb_stor_dbg(us, "-- sending exit command to thread\n");
	complete(&us->cmnd_ready);
	if (us->ctl_thread)
		kthread_stop(us->ctl_thread);

	/* Call the destructor routine, if it exists */
	if (us->extra_destructor) {
		usb_stor_dbg(us, "-- calling extra_destructor()\n");
		us->extra_destructor(us->extra);
	}

	/* Free the extra data and the URB */
	kfree(us->extra);
	usb_free_urb(us->current_urb);
}

/* Dissociate from the USB device */
static void dissociate_dev(struct us_data *us)
{
	/* Free the buffers */
	kfree(us->cr);
	usb_free_coherent(us->pusb_dev, US_IOBUF_SIZE, us->iobuf, us->iobuf_dma);

	/* Remove our private data from the interface */
	usb_set_intfdata(us->pusb_intf, NULL);
}

/* First stage of disconnect processing: stop SCSI scanning,
 * remove the host, and stop accepting new commands
 */
static void quiesce_and_remove_host(struct us_data *us)
{
	struct Scsi_Host *host = us_to_host(us);

	/* If the device is really gone, cut short reset delays */
	if (us->pusb_dev->state == USB_STATE_NOTATTACHED) {
		set_bit(US_FLIDX_DISCONNECTING, &us->dflags);
		wake_up(&us->delay_wait);
	}

	/* Prevent SCSI scanning (if it hasn't started yet)
	 * or wait for the SCSI-scanning routine to stop.
	 */
	cancel_delayed_work_sync(&us->scan_dwork);

	/* Balance autopm calls if scanning was cancelled */
	if (test_bit(US_FLIDX_SCAN_PENDING, &us->dflags))
		usb_autopm_put_interface_no_suspend(us->pusb_intf);

	/* Removing the host will perform an orderly shutdown: caches
	 * synchronized, disks spun down, etc.
	 */
	scsi_remove_host(host);

	/* Prevent any new commands from being accepted and cut short
	 * reset delays.
	 */
	scsi_lock(host);
	set_bit(US_FLIDX_DISCONNECTING, &us->dflags);
	scsi_unlock(host);
	wake_up(&us->delay_wait);
}

/* Second stage of disconnect processing: deallocate all resources */
static void release_everything(struct us_data *us)
{
	usb_stor_release_resources(us);
	dissociate_dev(us);

	/* Drop our reference to the host; the SCSI core will free it
	 * (and "us" along with it) when the refcount becomes 0. */
	scsi_host_put(us_to_host(us));
}

/* Delayed-work routine to carry out SCSI-device scanning */
static void usb_stor_scan_dwork(struct work_struct *work)
{
	struct us_data *us = container_of(work, struct us_data,
			scan_dwork.work);
	struct device *dev = &us->pusb_intf->dev;

	/* daveti: for the trusted device */
	int trusted_data_len;
	u8 *trusted_data;
	struct timeval start_tv, end_tv;

	dev_dbg(dev, "starting scan\n");

	/* For bulk-only devices, determine the max LUN value */
	if (us->protocol == USB_PR_BULK && !(us->fflags & US_FL_SINGLE_LUN)) {
		mutex_lock(&us->dev_mutex);
		us->max_lun = usb_stor_Bulk_max_lun(us);
		mutex_unlock(&us->dev_mutex);
	}

	/* daveti: Skip the provusb functionality */
	if (us_trusted_dev_provusb_disable)
		goto PROVUSB_DISABLE;

        /* daveti: shall we init the TPM attestation here? */
        struct usb_device *trust_dev = us->pusb_dev;
        int result;
        if (le16_to_cpu(trust_dev->descriptor.idVendor) == 0xb000 ||
		us_trusted_dev_ut_phase == 1)
	{
		/* Dump the UT mode */
		printk(KERN_INFO "daveti2: trusted dev UT mode [%u]\n",
			us_trusted_dev_ut_phase);
		/* ProvUSB perf */
		if (us_trusted_dev_perf)
			do_gettimeofday(&start_tv);
		/* Get the nonce and PCR mask from the device */
		dev_dbg(dev, "daveti2: init TPM attestation for the Trusted mass storage\n");
		if ((us_trusted_dev_ut_phase == 0) | (us_trusted_dev_ut_phase == 2)) {
			mutex_lock(&us->dev_mutex);
			result = usb_stor_Ctrl_get_nonce(us, &us_trusted_dev_ctrl_block);
			mutex_unlock(&us->dev_mutex);
		}
		else {
			/* For UT phase 1, fix the nonce and pcr mask */
			result = 0;
			memset(us_trusted_dev_ctrl_block.iobuf, 0x1, US_TRUSTED_DEV_TPM_ATT_NONCE_LEN);
			memset(us_trusted_dev_ctrl_block.iobuf+US_TRUSTED_DEV_TPM_ATT_NONCE_LEN, 0xff, 1);
			memset(us_trusted_dev_ctrl_block.iobuf+US_TRUSTED_DEV_TPM_ATT_NONCE_LEN+1, 0x0, 2);
		}
		printk(KERN_INFO "daveti2: TPM ATT init with rtn [%d]\n"
			"Dump the TPM ATT init:\n", result);
		if (us_trusted_dev_debug)
			print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
				us_trusted_dev_ctrl_block.iobuf,
				US_TRUSTED_DEV_TPM_ATT_REQ_LEN, 0);

		/* Send the nonce and PCR mask to the tpmd */
		dev_dbg(dev, "daveti2: send the nonce and PCR mask to the tpmd\n");
		result = 0;
		if ((us_trusted_dev_ut_phase == 0) | (us_trusted_dev_ut_phase == 1)) {
			result = us_trusted_dev_tpm_nl_send_request(us_trusted_dev_ctrl_block.iobuf,
					US_TRUSTED_DEV_TPM_ATT_REQ_LEN);
			if (result != 0)
				printk(KERN_ERR "daveti2: us_trusted_dev_tpm_nl_send_request() failure\n");
		}
		printk(KERN_INFO "daveti2: sending the nonce with rtn [%d]\n", result);

		/* ADSC debug */
		if (us_trusted_dev_adsc_debug) {
			dev_dbg(dev, "daveti2: ADSC DEBUG\n");
			/* NOTE: the ADSC debug is used to verify if iobuf has to be used - NO
			 * and the max number of bytes EP0 would accept - 32/64/128?
			 * According to the MxPS in the device descriptor, it should be 64.
			 * However, usbmon trial using TPM quote only dumps 32 bytes.
			 * We will try 30, 32, 64, 128, 256 and 304 (TPM quote) to find the MxPS.
			 * daveti
			 * Jul 23, 2014
			 * Add 512 bytes
			 * daveti
			 * Aug 7, 2014
			 */
			u8 debug_data[US_TRUSTED_DEV_ADSC_DEBUG_REQ6_LEN]; /* 512 bytes */
			/* 30 using iobuf */
			memset(debug_data, 0x2,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN); /* 30 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN, 1);
                        mutex_unlock(&us->dev_mutex);
			printk(KERN_INFO "daveti2: ADSC debug [%d] using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN, result);
			/* 30 not using iobuf */
			memset(debug_data, 0x3,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN); /* 30 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
			printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ1_LEN, result);
			/* 32 not using iobuf */
                        memset(debug_data, 0x4,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ2_LEN); /* 32 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ2_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ2_LEN, result);
			/* 64 not using iobuf */
                        memset(debug_data, 0x5,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ3_LEN); /* 64 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ3_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ3_LEN, result);
			/* 128 not using iobuf */
                        memset(debug_data, 0x6,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN); /* 128 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN, result);
                        /* 128 not using iobuf */
                        memset(debug_data, 0x7,
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN); /* 128 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
                                        US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ4_LEN, result);
                        /* 256 not using iobuf */
                        memset(debug_data, 0x8,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN); /* 256 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
					US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
				US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, result);
                        /* 256 not using iobuf */
                        memset(debug_data, 0x9,
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN); /* 256 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
                                        US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, result);
			/* 512 not using iobuf */
                        memset(debug_data, 0xa,
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ6_LEN); /* 512 bytes */
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
                                        US_TRUSTED_DEV_ADSC_DEBUG_REQ6_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] not using iobuf rtn [%d]\n",
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ6_LEN, result);
			/* 256 AIK not using iobuf */
			/* daveti: now we know it works...
			 * Aug 7, 2014
			memcpy(debug_data,
				us_trusted_dev_ctrl_block.tpm_quote_store.aik,
				US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN);
			mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
                                        US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] AIK not using iobuf rtn [%d]\n",
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN, result);
			*/
			/* 28 AIK not suing iobuf */
			/* daveti: now we know it works...
			 * Aug 7, 2014
			memcpy(debug_data,
                                (us_trusted_dev_ctrl_block.tpm_quote_store.aik +
                                US_TRUSTED_DEV_ADSC_DEBUG_REQ5_LEN), 28);
                        mutex_lock(&us->dev_mutex);
                        result = usb_stor_Ctrl_send_adsc_debug(us, debug_data,
                                        28, 0);
                        mutex_unlock(&us->dev_mutex);
                        printk(KERN_INFO "daveti2: ADSC debug [%d] AIK not using iobuf rtn [%d]\n",
                                28, result);
			*/
		}

		/* Wait for the TPM quote from the tpmd */
		dev_dbg(dev, "daveti2: wait for the TPM quote from the tpmd\n");
		if ((us_trusted_dev_ut_phase == 0) | (us_trusted_dev_ut_phase == 1)) {
			if (us_trusted_dev_nl_wakeup) {
				/* Wait for wakeup */
				wait_event(us_trusted_dev_ctrl_block.tpm_wait,
					us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go);
			} else {
				/* Sleep wait here ? */
				while (us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go ==
					US_TRUSTED_DEV_TPM_QUOTE_NOT_READY) {
					/* Sleep 10 msec */
					msleep(US_TRUSTED_DEV_TPM_QUOTE_WAIT_TIME);
				}
			}
		}
		else {
			/* For UT phase 2, fix the quote */
			memset(us_trusted_dev_ctrl_block.tpm_quote_store.quote,
				0x1, US_TRUSTED_DEV_TPM_ATT_REP_LEN);
			/* For UT phase 2, fix the aik as well */
			memset(us_trusted_dev_ctrl_block.tpm_quote_store.aik,
				0x1, US_TRUSTED_DEV_TPM_ATT_AIK_PUB_LEN);
		}

		/* Send the TPM AIK and quote to the device */
		dev_dbg(dev, "daveti2: send the TPM AIK and quote to the trusted device\n");
		if ((us_trusted_dev_ut_phase == 0) | (us_trusted_dev_ut_phase == 2)) {
                        /* Grab the lock */
			/* NOTE: Be careful to avoid dead lock here
			 * Jul 15, 2014
			 * daveti
			 *
			 * Rewrite this part to support the new protocol,
			 * which needs to send both AIK and Quote from the host
			 * side to the trusted device.
			 * AIK is used for indexing in the device's TPM store
			 * Quote is used for constructing validation data and the signature
			 * Jan 21, 2015
			 * daveti
			 */
			/* NOTE: Have to use stack buffer because of DMA issue */
			u8 trusted_data_buf[US_TRUSTED_DEV_TPM_ATT_REP_LEN];
			/* Lock the trusted dev */
			mutex_lock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);
			/* 1st: send the TPM AIK */
			trusted_data_len = US_TRUSTED_DEV_TPM_ATT_AIK_PUB_LEN;
			memcpy(trusted_data_buf,
				us_trusted_dev_ctrl_block.tpm_quote_store.aik,
				trusted_data_len);
			/* Lock the dev */
			mutex_lock(&us->dev_mutex);
			result = usb_stor_Ctrl_send_adsc(us, trusted_data_buf, trusted_data_len);
			/* Free the dev */
			mutex_unlock(&us->dev_mutex);
			printk(KERN_INFO "daveti2: ADSC send with rtn [%d]\n", result);
			us_trusted_dev_ctrl_block.tpm_quote_store.sent_len += result;
			if (result != trusted_data_len) {
				pr_err("daveti2: ADSC send TPM AIK failed [%d/%d]\n", result, trusted_data_len);
				/* Currently we will move on */
			}
			/* 2nd: send the TPM quote */
			trusted_data_len = US_TRUSTED_DEV_TPM_ATT_REP_LEN;
			memcpy(trusted_data_buf,
				us_trusted_dev_ctrl_block.tpm_quote_store.quote,
				trusted_data_len);
			/* Lock the dev */
			mutex_lock(&us->dev_mutex);
			result = usb_stor_Ctrl_send_adsc(us, trusted_data_buf, trusted_data_len);
			/* Free the dev */
			mutex_unlock(&us->dev_mutex);
			pr_info("daveti2: ADSC send with rtn [%d]\n", result);
			us_trusted_dev_ctrl_block.tpm_quote_store.sent_len += result;
			if (result != trusted_data_len) {
				pr_err("daveti2: ADSC send TPM quote failed [%d/%d]\n", result, trusted_data_len);
				/* Try to send again in future */
			}
			/* Reinit the rtg flag */
			us_trusted_dev_ctrl_block.tpm_quote_store.ready_to_go =
					US_TRUSTED_DEV_TPM_QUOTE_NOT_READY;
			/* TODO: how to implement a routine work for this periodically... */
			/* Free the trusted dev */
			mutex_unlock(&us_trusted_dev_ctrl_block.tpm_quote_store.lock);
		}
		else {
			result = 0;
		}

		/* ProvUSB perf done */
		if (us_trusted_dev_perf) {
			do_gettimeofday(&end_tv);
			pr_info("provusb-perf: TPM attestation took [%lu] us\n",
				PROVUSB_MBM_SUB_TV(start_tv, end_tv));
		}

		/* Try to dump the AIK even if we are not sending */
		if (us_trusted_dev_ctrl_block.tpm_quote_store.aik_pub_key) {
			pr_info("daveti2: Dump the TPM AIK pub key:\n");
			if (us_trusted_dev_debug)
				print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
					us_trusted_dev_ctrl_block.tpm_quote_store.aik,
   					US_TRUSTED_DEV_TPM_ATT_AIK_PUB_LEN, 0);
		}

		/* Always dump the quote even if we are not sending */
		pr_info("daveti2: Dump the TPM ATT quote:\n");
		if (us_trusted_dev_debug)
			print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
               			us_trusted_dev_ctrl_block.tpm_quote_store.quote,
				US_TRUSTED_DEV_TPM_ATT_REP_LEN, 0);

		dev_dbg(dev, "daveti2: TPM attestation done\n");

		/* Delay the scan to allow the device to recv the ADSC request
		 * and avoid the host to reset the config of the device
		 */
		printk(KERN_INFO "daveti2: delay the scan with [%d] ms\n",
			US_TRUSTED_DEV_SCAN_DELAY_TIME);
		msleep(US_TRUSTED_DEV_SCAN_DELAY_TIME);
        }

PROVUSB_DISABLE:
	/* daveti: start the scan only after the whole TPM attestation */
	scsi_scan_host(us_to_host(us));
	dev_dbg(dev, "scan complete\n");

	/* Should we unbind if no devices were detected? */

	usb_autopm_put_interface(us->pusb_intf);
	clear_bit(US_FLIDX_SCAN_PENDING, &us->dflags);

//daveti
	/* Delay the general perf ending here */
	if (us_trusted_dev_perf_kernel_logging)
		pr_info("provusb-perf: scan done\n");
}

static unsigned int usb_stor_sg_tablesize(struct usb_interface *intf)
{
	struct usb_device *usb_dev = interface_to_usbdev(intf);

	if (usb_dev->bus->sg_tablesize) {
		return usb_dev->bus->sg_tablesize;
	}
	return SG_ALL;
}

/* First part of general USB mass-storage probing */
int usb_stor_probe1(struct us_data **pus,
		struct usb_interface *intf,
		const struct usb_device_id *id,
		struct us_unusual_dev *unusual_dev)
{
	struct Scsi_Host *host;
	struct us_data *us;
	int result;

//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti: into %s\n", __FUNCTION__);

	dev_info(&intf->dev, "USB Mass Storage device detected\n");

	/*
	 * Ask the SCSI layer to allocate a host structure, with extra
	 * space at the end for our private us_data structure.
	 */
	host = scsi_host_alloc(&usb_stor_host_template, sizeof(*us));
	if (!host) {
		dev_warn(&intf->dev, "Unable to allocate the scsi host\n");
		return -ENOMEM;
	}

	/*
	 * Allow 16-byte CDBs and thus > 2TB
	 */
	host->max_cmd_len = 16;
	host->sg_tablesize = usb_stor_sg_tablesize(intf);
	*pus = us = host_to_us(host);
	mutex_init(&(us->dev_mutex));
	us_set_lock_class(&us->dev_mutex, intf);
	init_completion(&us->cmnd_ready);
	init_completion(&(us->notify));
	init_waitqueue_head(&us->delay_wait);
	INIT_DELAYED_WORK(&us->scan_dwork, usb_stor_scan_dwork);

	/* Associate the us_data structure with the USB device */
	result = associate_dev(us, intf);
	if (result)
		goto BadDevice;

	/* Get the unusual_devs entries and the descriptors */
	result = get_device_info(us, id, unusual_dev);
	if (result)
		goto BadDevice;

	/* Get standard transport and protocol settings */
	get_transport(us);
	get_protocol(us);

	/* Give the caller a chance to fill in specialized transport
	 * or protocol settings.
	 */
//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: done %s\n", __FUNCTION__);

	return 0;

BadDevice:
	usb_stor_dbg(us, "storage_probe() failed\n");
	release_everything(us);
	return result;
}
EXPORT_SYMBOL_GPL(usb_stor_probe1);

/* Second part of general USB mass-storage probing */
int usb_stor_probe2(struct us_data *us)
{
	int result;
	struct device *dev = &us->pusb_intf->dev;

//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into %s\n", __FUNCTION__);

	/* Make sure the transport and protocol have both been set */
	if (!us->transport || !us->proto_handler) {
		result = -ENXIO;
		goto BadDevice;
	}
	usb_stor_dbg(us, "Transport: %s\n", us->transport_name);
	usb_stor_dbg(us, "Protocol: %s\n", us->protocol_name);

	/* fix for single-lun devices */
	if (us->fflags & US_FL_SINGLE_LUN)
		us->max_lun = 0;

	if (!(us->fflags & US_FL_SCM_MULT_TARG))
		us_to_host(us)->max_id = 1;

	/* Find the endpoints and calculate pipe values */
	result = get_pipes(us);
	if (result)
		goto BadDevice;

	/*
	 * If the device returns invalid data for the first READ(10)
	 * command, indicate the command should be retried.
	 */
	if (us->fflags & US_FL_INITIAL_READ10)
		set_bit(US_FLIDX_REDO_READ10, &us->dflags);

	/* Acquire all the other resources and add the host */
	result = usb_stor_acquire_resources(us);
	if (result)
		goto BadDevice;
	snprintf(us->scsi_name, sizeof(us->scsi_name), "usb-storage %s",
					dev_name(&us->pusb_intf->dev));
	result = scsi_add_host(us_to_host(us), dev);
	if (result) {
		dev_warn(dev,
				"Unable to add the scsi host\n");
		goto BadDevice;
	}

	/* Submit the delayed_work for SCSI-device scanning */
	usb_autopm_get_interface_no_resume(us->pusb_intf);
	set_bit(US_FLIDX_SCAN_PENDING, &us->dflags);

	if (delay_use > 0)
		dev_dbg(dev, "waiting for device to settle before scanning\n");
	queue_delayed_work(system_freezable_wq, &us->scan_dwork,
			delay_use * HZ);
//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: done %s\n", __FUNCTION__);

	return 0;

	/* We come here if there are any problems */
BadDevice:
	usb_stor_dbg(us, "storage_probe() failed\n");
	release_everything(us);
	return result;
}
EXPORT_SYMBOL_GPL(usb_stor_probe2);

/* Handle a USB mass-storage disconnect */
void usb_stor_disconnect(struct usb_interface *intf)
{
	struct us_data *us = usb_get_intfdata(intf);

	quiesce_and_remove_host(us);
	release_everything(us);

	/* daveti: say goodbye to the tpmd */
	us_trusted_dev_free_tpmd();

	/* daveti: clear the ctrl block for the trusted dev */
	us_trusted_dev_free_ctrl_block(&us_trusted_dev_ctrl_block);
}
EXPORT_SYMBOL_GPL(usb_stor_disconnect);

/* The main probe routine for standard devices */
static int storage_probe(struct usb_interface *intf,
			 const struct usb_device_id *id)
{
	struct us_unusual_dev *unusual_dev;
	struct us_data *us;
	int result;
	int size;

//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: into %s\n", __FUNCTION__);

	/*
	 * If the device isn't standard (is handled by a subdriver
	 * module) then don't accept it.
	 */
	if (usb_usual_ignore_device(intf))
		return -ENXIO;

	/*
	 * Call the general probe procedures.
	 *
	 * The unusual_dev_list array is parallel to the usb_storage_usb_ids
	 * table, so we use the index of the id entry to find the
	 * corresponding unusual_devs entry.
	 */

	size = ARRAY_SIZE(us_unusual_dev_list);
	if (id >= usb_storage_usb_ids && id < usb_storage_usb_ids + size) {
		unusual_dev = (id - usb_storage_usb_ids) + us_unusual_dev_list;
	} else {
		unusual_dev = &for_dynamic_ids;

		dev_dbg(&intf->dev, "Use Bulk-Only transport with the Transparent SCSI protocol for dynamic id: 0x%04x 0x%04x\n",
			id->idVendor, id->idProduct);
	}

//daveti: init the ctrl block for the trusted dev
	us_trusted_dev_init_ctrl_block(&us_trusted_dev_ctrl_block);

	result = usb_stor_probe1(&us, intf, id, unusual_dev);
	if (result)
		return result;

	/* No special transport or protocol settings in the main module */

	result = usb_stor_probe2(us);
//daveti
	if (us_trusted_dev_debug)
		printk(KERN_INFO "daveti2: done %s\n", __FUNCTION__);

	if (us_trusted_dev_perf_kernel_logging)
		pr_info("provusb-perf: new device starts to work\n");

	return result;
}

static struct usb_driver usb_storage_driver = {
	.name =		"usb-storage",
	.probe =	storage_probe,
	.disconnect =	usb_stor_disconnect,
	.suspend =	usb_stor_suspend,
	.resume =	usb_stor_resume,
	.reset_resume =	usb_stor_reset_resume,
	.pre_reset =	usb_stor_pre_reset,
	.post_reset =	usb_stor_post_reset,
	.id_table =	usb_storage_usb_ids,
	.supports_autosuspend = 1,
	.soft_unbind =	1,
};

module_usb_driver(usb_storage_driver);
